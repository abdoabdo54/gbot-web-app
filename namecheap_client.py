\"\"\"\nNamecheap API Client for DNS management.\n\nImplements:\n- get_domains()\n- get_hosts(domain)\n- set_hosts(domain, hosts)\n- add_or_update_record(domain, host, type, value, ttl)\n- add_or_update_txt(domain, host, value, ttl)\n\nUses requests and xml.etree.ElementTree for XML parsing.\n\"\"\"\nfrom __future__ import annotations\n\nimport logging\nimport xml.etree.ElementTree as ET\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\n\n\nclass NamecheapAPIError(Exception):\n    \"\"\"Exception class for Namecheap API errors.\"\"\"\n\n\nclass NamecheapClient:\n    \"\"\"Simple Namecheap API client.\n\n    Parameters\n    ----------\n    api_user : str\n        Namecheap API user.\n    api_key : str\n        Namecheap API key.\n    username : str\n        Namecheap username (often same as api_user).\n    client_ip : str\n        Whitelisted client IP for Namecheap API access.\n    api_url : str\n        Namecheap API base URL, e.g., https://api.namecheap.com/xml.response (or sandbox URL).\n    \"\"\"\n\n    def __init__(\n        self,\n        api_user: str,\n        api_key: str,\n        username: str,\n        client_ip: str,\n        api_url: str = \"https://api.namecheap.com/xml.response\",\n        timeout: int = 30,\n    ) -> None:\n        self.api_user = api_user\n        self.api_key = api_key\n        self.username = username\n        self.client_ip = client_ip\n        self.api_url = api_url\n        self.timeout = timeout\n\n    def _request(self, command: str, params: Optional[Dict[str, str]] = None) -> ET.Element:\n        data = {\n            \"ApiUser\": self.api_user,\n            \"ApiKey\": self.api_key,\n            \"UserName\": self.username,\n            \"ClientIp\": self.client_ip,\n            \"Command\": command,\n        }\n        if params:\n            data.update(params)\n\n        logging.debug(f\"Namecheap request: {command} params={ {k:v for k,v in data.items() if k != 'ApiKey'} }\")\n        try:\n            resp = requests.post(self.api_url, data=data, timeout=self.timeout)\n        except Exception as e:\n            raise NamecheapAPIError(f\"Network error calling Namecheap: {e}\")\n\n        if resp.status_code != 200:\n            raise NamecheapAPIError(f\"HTTP {resp.status_code} from Namecheap: {resp.text[:200]}\")\n\n        try:\n            root = ET.fromstring(resp.text)\n        except ET.ParseError as pe:\n            raise NamecheapAPIError(f\"Invalid XML from Namecheap: {pe}\\nBody: {resp.text[:300]}\")\n\n        status = root.attrib.get(\"Status\", \"ERROR\")\n        if status != \"OK\":\n            # Try to extract error message\n            errors = root.findall(\".//Errors/Error\")\n            msg = \"; \".join(e.text or \"\" for e in errors) or \"Unknown Namecheap error\"\n            raise NamecheapAPIError(msg)\n\n        return root\n\n    def get_domains(self) -> List[Dict[str, str]]:\n        \"\"\"Return list of domains with basic info.\n\n        Returns a list of dicts: {Domain, Expires, IsOurDNS}\n        \"\"\"\n        root = self._request(\"namecheap.domains.getList\")\n        result = []\n        for d in root.findall(\".//DomainGetListResult/Domain\"):\n            result.append(\n                {\n                    \"Domain\": d.attrib.get(\"Name\", \"\"),\n                    \"Expires\": d.attrib.get(\"Expires\", \"\"),\n                    \"IsOurDNS\": d.attrib.get(\"IsOurDNS\", \"false\").lower() == \"true\",\n                }\n            )\n        return result\n\n    def get_hosts(self, domain: str) -> List[Dict[str, str]]:\n        \"\"\"Return DNS hosts for a domain.\n\n        Returns list of dicts: {HostName, RecordType, Address, TTL, MXPref}\n        \"\"\"\n        sld, tld = self._split_domain(domain)\n        root = self._request(\n            \"namecheap.domains.dns.getHosts\",\n            {\"SLD\": sld, \"TLD\": tld},\n        )\n        hosts: List[Dict[str, str]] = []\n        for h in root.findall(\".//DomainDNSGetHostsResult/host\"):\n            hosts.append(\n                {\n                    \"HostName\": h.attrib.get(\"Name\", \"\"),\n                    \"RecordType\": h.attrib.get(\"Type\", \"\"),\n                    \"Address\": h.attrib.get(\"Address\", \"\"),\n                    \"TTL\": h.attrib.get(\"TTL\", \"\"),\n                    \"MXPref\": h.attrib.get(\"MXPref\", \"\"),\n                }\n            )\n        return hosts\n\n    def set_hosts(self, domain: str, hosts: List[Dict[str, str]]) -> bool:\n        \"\"\"Set all hosts for the domain with provided list.\n\n        hosts: list of dicts with keys HostName, RecordType, Address, TTL, MXPref (optional)\n        \"\"\"\n        sld, tld = self._split_domain(domain)\n        params: Dict[str, str] = {\"SLD\": sld, \"TLD\": tld}\n        for idx, h in enumerate(hosts, start=1):\n            params[f\"HostName{idx}\"] = h.get(\"HostName\", \"\")\n            params[f\"RecordType{idx}\"] = h.get(\"RecordType\", \"\")\n            params[f\"Address{idx}\"] = h.get(\"Address\", \"\")\n            if h.get(\"MXPref\"):\n                params[f\"MXPref{idx}\"] = str(h.get(\"MXPref\"))\n            if h.get(\"TTL\"):\n                params[f\"TTL{idx}\"] = str(h.get(\"TTL\"))\n\n        self._request(\"namecheap.domains.dns.setHosts\", params)\n        return True\n\n    def add_or_update_record(\n        self,\n        domain: str,\n        host: str,\n        rtype: str,\n        value: str,\n        ttl: int = 1800,\n        mx_pref: Optional[int] = None,\n    ) -> Tuple[bool, List[Dict[str, str]]]:\n        \"\"\"Add or update a single record by merging with current hosts.\n\n        Returns (changed: bool, new_hosts: list)\n        \"\"\"\n        current = self.get_hosts(domain)\n\n        normalized_host = host if host != \"@\" else \"@\"\n        changed = False\n        new_hosts: List[Dict[str, str]] = []\n        updated = False\n\n        for h in current:\n            if h.get(\"HostName\") == normalized_host and h.get(\"RecordType\", \"\").upper() == rtype.upper():\n                # Update existing\n                if (\n                    str(h.get(\"Address\", \"\")) != str(value)\n                    or str(h.get(\"TTL\", \"\")) != str(ttl)\n                    or (mx_pref and str(h.get(\"MXPref\", \"\")) != str(mx_pref))\n                ):\n                    changed = True\n                new_hosts.append(\n                    {\n                        \"HostName\": normalized_host,\n                        \"RecordType\": rtype.upper(),\n                        \"Address\": value,\n                        \"TTL\": str(ttl),\n                        \"MXPref\": str(mx_pref) if mx_pref is not None else \"\",\n                    }\n                )\n                updated = True\n            else:\n                new_hosts.append(h)\n\n        if not updated:\n            changed = True\n            new_hosts.append(\n                {\n                    \"HostName\": normalized_host,\n                    \"RecordType\": rtype.upper(),\n                    \"Address\": value,\n                    \"TTL\": str(ttl),\n                    \"MXPref\": str(mx_pref) if mx_pref is not None else \"\",\n                }\n            )\n\n        if changed:\n            self.set_hosts(domain, new_hosts)\n        return changed, new_hosts\n\n    def add_or_update_txt(self, domain: str, host: str, value: str, ttl: int = 300) -> Tuple[bool, List[Dict[str, str]]]:\n        return self.add_or_update_record(domain, host, \"TXT\", value, ttl)\n\n    @staticmethod\n    def _split_domain(domain: str) -> Tuple[str, str]:\n        parts = domain.split(\".\")\n        if len(parts) < 2:\n            raise NamecheapAPIError(f\"Invalid domain: {domain}\")\n        return parts[0], \".\".join(parts[1:])\n